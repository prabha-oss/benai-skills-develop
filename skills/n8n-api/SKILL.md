---
name: n8n-api
description: All n8n workflow operations via REST API. Use for listing, getting, creating, updating, deleting, activating/deactivating workflows, managing tags, variables, executions, and source control.
---

# n8n-api Skill

**Purpose**: All n8n workflow operations via REST API

---

## Pre-Flight Checklist

Before executing any operation, you MUST verify the setup by reading the `.env` file in the current working directory.

### Step 1: Read .env File

Use the Read tool to check for `.env` in the current working directory.

### Step 2: Handle Missing .env File

**IMPORTANT**: If `.env` doesn't exist, you MUST immediately create it using the Write tool with this content:

```
# BenAI n8n Skills Configuration
# Generated by benai-skills plugin

N8N_API_URL=
N8N_API_KEY=
N8N_CREDENTIALS_TEMPLATE_URL=
```

Do NOT ask the user to create this file - create it yourself automatically.

### Step 3: Check Required Variables

After reading or creating `.env`, check that these variables have values:

| Variable | Required | Description |
|----------|----------|-------------|
| `N8N_API_URL` | Yes | n8n instance URL (no trailing slash) |
| `N8N_API_KEY` | Yes | n8n API key |

### Step 4: Prompt for Missing Values

If `N8N_API_URL` or `N8N_API_KEY` is empty, ask the user:

```
n8n API Configuration Required

Please provide:
1. Your n8n instance URL (e.g., https://your-n8n.app.n8n.cloud)
2. Your n8n API key

You can find your API key in n8n at: Settings -> API -> Create API Key
```

After user provides values, update `.env` with the values using the Edit tool.

---

## Node Selection Priority

**PREFER native n8n nodes. Only use HTTP Request or Code nodes when necessary.**

| Priority | Node Type | Use When |
|----------|-----------|----------|
| 1 | Native node | Built-in node exists (Slack, Sheets, OpenAI, etc.) |
| 2 | HTTP Request | Native node has known issues OR no node exists for the API |
| 3 | Code node | Complex transformation logic not possible with built-in nodes |

**Always check the credentials template first** - if a native node is configured there, use it.

**Never use mock data** - no placeholder URLs, no fake IDs, no "REPLACE_ME" values. Ask the user for real values.

---

## API Methods Reference

**CRITICAL**: The n8n API uses specific HTTP methods:

| Operation | Method | Endpoint |
|-----------|--------|----------|
| List/Get | GET | `/api/v1/workflows` |
| Create | POST | `/api/v1/workflows` |
| Update | **PUT** (not PATCH!) | `/api/v1/workflows/{id}` |
| Delete | DELETE | `/api/v1/workflows/{id}` |
| Activate | **POST** | `/api/v1/workflows/{id}/activate` |
| Deactivate | **POST** | `/api/v1/workflows/{id}/deactivate` |

---

## API Call Format

**IMPORTANT**: Always use this exact format for API calls to avoid encoding issues:

```bash
export $(cat .env | grep -v '^#' | xargs) && curl -s "${N8N_API_URL}/api/v1/ENDPOINT" -H "X-N8N-API-KEY: ${N8N_API_KEY}"
```

For POST/PUT/DELETE requests, add the method and data:

```bash
export $(cat .env | grep -v '^#' | xargs) && curl -s -X POST "${N8N_API_URL}/api/v1/ENDPOINT" -H "X-N8N-API-KEY: ${N8N_API_KEY}" -H "Content-Type: application/json" -d 'JSON_DATA'
```

**Key points:**
- Load env vars first with `export $(cat .env | grep -v '^#' | xargs)`
- Use double quotes around URL and header values with variable interpolation
- Use single quotes around JSON data
- Pipe to `| jq .` for formatted output

---

## READ Operations

### List All Workflows

```bash
export $(cat .env | grep -v '^#' | xargs) && curl -s "${N8N_API_URL}/api/v1/workflows" -H "X-N8N-API-KEY: ${N8N_API_KEY}" | jq .
```

### Get Workflow by ID

```bash
export $(cat .env | grep -v '^#' | xargs) && curl -s "${N8N_API_URL}/api/v1/workflows/{WORKFLOW_ID}" -H "X-N8N-API-KEY: ${N8N_API_KEY}" | jq .
```

### List Tags

```bash
export $(cat .env | grep -v '^#' | xargs) && curl -s "${N8N_API_URL}/api/v1/tags" -H "X-N8N-API-KEY: ${N8N_API_KEY}" | jq .
```

### List Variables

```bash
export $(cat .env | grep -v '^#' | xargs) && curl -s "${N8N_API_URL}/api/v1/variables" -H "X-N8N-API-KEY: ${N8N_API_KEY}" | jq .
```

### List Executions

**IMPORTANT**: Always use `?limit=` to fetch only recent executions. Never fetch all.

```bash
export $(cat .env | grep -v '^#' | xargs) && curl -s "${N8N_API_URL}/api/v1/executions?limit=2" -H "X-N8N-API-KEY: ${N8N_API_KEY}" | jq .
```

Filter by workflow:
```bash
export $(cat .env | grep -v '^#' | xargs) && curl -s "${N8N_API_URL}/api/v1/executions?workflowId={WORKFLOW_ID}&limit=2" -H "X-N8N-API-KEY: ${N8N_API_KEY}" | jq .
```

### Get Execution by ID (with error details)

```bash
export $(cat .env | grep -v '^#' | xargs) && curl -s "${N8N_API_URL}/api/v1/executions/{EXECUTION_ID}?includeData=true" -H "X-N8N-API-KEY: ${N8N_API_KEY}" | jq .
```

---

## WRITE Operations

### Create Workflow

```bash
export $(cat .env | grep -v '^#' | xargs) && curl -s -X POST "${N8N_API_URL}/api/v1/workflows" -H "X-N8N-API-KEY: ${N8N_API_KEY}" -H "Content-Type: application/json" -d '{
  "name": "My Workflow",
  "nodes": [],
  "connections": {},
  "settings": {"executionOrder": "v1"}
}' | jq .
```

### Update Workflow (USE PUT, NOT PATCH!)

**CRITICAL**: Use PUT method, not PATCH. PATCH will return "method not allowed".

```bash
export $(cat .env | grep -v '^#' | xargs) && curl -s -X PUT "${N8N_API_URL}/api/v1/workflows/{WORKFLOW_ID}" -H "X-N8N-API-KEY: ${N8N_API_KEY}" -H "Content-Type: application/json" -d '{
  "name": "Updated Name",
  "nodes": [],
  "connections": {},
  "settings": {"executionOrder": "v1"}
}' | jq .
```

### Delete Workflow

```bash
export $(cat .env | grep -v '^#' | xargs) && curl -s -X DELETE "${N8N_API_URL}/api/v1/workflows/{WORKFLOW_ID}" -H "X-N8N-API-KEY: ${N8N_API_KEY}" | jq .
```

### Activate Workflow (USE DEDICATED ENDPOINT!)

**CRITICAL**: Use the dedicated activate endpoint, NOT PUT with `{"active": true}`.

```bash
export $(cat .env | grep -v '^#' | xargs) && curl -s -X POST "${N8N_API_URL}/api/v1/workflows/{WORKFLOW_ID}/activate" -H "X-N8N-API-KEY: ${N8N_API_KEY}" | jq .
```

### Deactivate Workflow

```bash
export $(cat .env | grep -v '^#' | xargs) && curl -s -X POST "${N8N_API_URL}/api/v1/workflows/{WORKFLOW_ID}/deactivate" -H "X-N8N-API-KEY: ${N8N_API_KEY}" | jq .
```

### Create Tag

```bash
export $(cat .env | grep -v '^#' | xargs) && curl -s -X POST "${N8N_API_URL}/api/v1/tags" -H "X-N8N-API-KEY: ${N8N_API_KEY}" -H "Content-Type: application/json" -d '{"name": "production"}' | jq .
```

### Create Variable

```bash
export $(cat .env | grep -v '^#' | xargs) && curl -s -X POST "${N8N_API_URL}/api/v1/variables" -H "X-N8N-API-KEY: ${N8N_API_KEY}" -H "Content-Type: application/json" -d '{"key": "MY_VAR", "value": "my-value"}' | jq .
```

### Delete Variable

```bash
export $(cat .env | grep -v '^#' | xargs) && curl -s -X DELETE "${N8N_API_URL}/api/v1/variables/{VARIABLE_ID}" -H "X-N8N-API-KEY: ${N8N_API_KEY}" | jq .
```

---

## Workflow Execution

### CRITICAL: How to Execute Workflows via API

**You CANNOT execute Manual Trigger workflows via API.** The n8n REST API does not support:
- `POST /api/v1/workflows/{id}/run` (does not exist)
- `POST /api/v1/executions` (does not exist)

**To execute a workflow via API, you MUST:**
1. Add a **Webhook trigger** node to the workflow
2. **Activate** the workflow using `POST /api/v1/workflows/{id}/activate`
3. Call the webhook URL

### Adding a Webhook Trigger for API Execution

When creating a workflow that needs API execution, include a webhook node:

```json
{
  "id": "webhook-trigger",
  "name": "Webhook",
  "type": "n8n-nodes-base.webhook",
  "typeVersion": 2,
  "position": [250, 300],
  "parameters": {
    "path": "my-webhook-path",
    "httpMethod": "POST",
    "responseMode": "lastNode"
  },
  "webhookId": "unique-webhook-id"
}
```

### Execute Workflow via Webhook (Production)

**Requirements**: Workflow must be ACTIVATED first.

```bash
export $(cat .env | grep -v '^#' | xargs) && curl -s -X POST "${N8N_API_URL}/webhook/{WEBHOOK_PATH}" -H "Content-Type: application/json" -d '{"key": "value"}' | jq .
```

### Execute Workflow via Test Webhook (Development)

**Requirements**: Workflow must be OPEN in n8n UI with "Listening for test events".

```bash
export $(cat .env | grep -v '^#' | xargs) && curl -s -X POST "${N8N_API_URL}/webhook-test/{WEBHOOK_PATH}" -H "Content-Type: application/json" -d '{"key": "value"}' | jq .
```

### Execution Flow for API-Triggered Workflows

1. Create workflow with webhook trigger
2. Activate: `POST /api/v1/workflows/{id}/activate`
3. Execute: `POST /webhook/{path}`
4. Check result: `GET /api/v1/executions?limit=1`

---

## Nodes Requiring Manual UI Configuration

**IMPORTANT**: Some nodes CANNOT be fully configured via API and require the user to complete setup in the n8n UI.

### Google Sheets Node

The Google Sheets node uses OAuth-based document picker. You CANNOT set `documentId` or `sheetName` via API with valid values.

**What to do:**
1. Create the workflow with the Google Sheets node
2. Set `documentId` and `sheetName` to placeholder objects (see below)
3. **Tell the user** they must open the workflow in n8n and select the spreadsheet manually

**Placeholder configuration (will cause WorkflowHasIssuesError if executed):**
```json
{
  "parameters": {
    "operation": "append",
    "documentId": {
      "__rl": true,
      "mode": "list",
      "value": ""
    },
    "sheetName": {
      "__rl": true,
      "mode": "list",
      "value": ""
    },
    "columns": {
      "mappingMode": "autoMapInputData",
      "value": {}
    }
  }
}
```

**If user provides a spreadsheet URL**, extract the ID and use:
```json
{
  "documentId": {
    "__rl": true,
    "mode": "id",
    "value": "SPREADSHEET_ID_FROM_URL"
  },
  "sheetName": {
    "__rl": true,
    "mode": "name",
    "value": "Sheet1"
  }
}
```

### Other Nodes Requiring UI Configuration

| Node | Reason | Solution |
|------|--------|----------|
| Google Sheets | OAuth document picker | Ask user for spreadsheet ID/URL or manual UI selection |
| Google Drive | OAuth file picker | Ask user for file/folder ID or manual UI selection |
| Notion | Database picker | Ask user for database ID or manual UI selection |
| Airtable | Base/Table picker | Ask user for base and table IDs |

**Always inform the user** when a workflow requires manual configuration in the n8n UI.

---

## Source Control Operations

### Pull from Remote

```bash
export $(cat .env | grep -v '^#' | xargs) && curl -s -X POST "${N8N_API_URL}/api/v1/source-control/pull" -H "X-N8N-API-KEY: ${N8N_API_KEY}" -H "Content-Type: application/json" -d '{"force": false}' | jq .
```

### Push to Remote

```bash
export $(cat .env | grep -v '^#' | xargs) && curl -s -X POST "${N8N_API_URL}/api/v1/source-control/push" -H "X-N8N-API-KEY: ${N8N_API_KEY}" -H "Content-Type: application/json" -d '{"message": "Update workflows"}' | jq .
```

---

## Workflow JSON Structure

When creating or updating workflows, use this structure:

```json
{
  "name": "Workflow Name",
  "nodes": [
    {
      "id": "unique-node-id",
      "name": "Node Display Name",
      "type": "n8n-nodes-base.nodeName",
      "typeVersion": 1,
      "position": [250, 300],
      "parameters": {},
      "credentials": {}
    }
  ],
  "connections": {
    "Source Node Name": {
      "main": [
        [
          {
            "node": "Target Node Name",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "settings": {
    "executionOrder": "v1",
    "saveManualExecutions": true,
    "saveDataErrorExecution": "all",
    "saveDataSuccessExecution": "all"
  }
}
```

---

## Common Pitfalls (AVOID THESE!)

### 0. Using HTTP Request when a native node exists
- **Wrong**: Using HTTP Request to call Slack API when `n8n-nodes-base.slack` exists
- **Right**: Use the native Slack node with credentials from template
- **Exception**: Native node has known bug or missing feature - then HTTP Request is acceptable

### 0b. Using mock/placeholder data
- **Wrong**: `"url": "https://api.example.com/placeholder"` or `"documentId": "REPLACE_ME"`
- **Right**: Use real URLs, real IDs, real credential references from template
- **If missing**: Ask the user for real values, don't guess or mock

### 1. Using PATCH instead of PUT for updates
- **Wrong**: `curl -X PATCH /api/v1/workflows/{id}`
- **Right**: `curl -X PUT /api/v1/workflows/{id}`

### 2. Trying to activate with PUT
- **Wrong**: `curl -X PUT /api/v1/workflows/{id} -d '{"active": true}'`
- **Right**: `curl -X POST /api/v1/workflows/{id}/activate`

### 3. Trying to execute Manual Trigger workflows via API
- **Wrong**: Expecting `POST /api/v1/workflows/{id}/run` to exist
- **Right**: Add a webhook trigger, activate workflow, call webhook URL

### 4. Leaving Google Sheets documentId empty and trying to execute
- **Wrong**: Creating workflow with empty `documentId.value` and executing
- **Right**: Either get spreadsheet ID from user, or warn them to configure in UI

### 5. Executing webhook before activating workflow
- **Wrong**: `POST /webhook/path` on inactive workflow
- **Right**: First `POST /api/v1/workflows/{id}/activate`, then `POST /webhook/path`

### 6. Fetching all executions when debugging
- **Wrong**: `GET /api/v1/executions` (fetches everything, overwhelming)
- **Right**: `GET /api/v1/executions?limit=2` (only recent, focused context)

### 7. Telling user to test instead of testing yourself
- **Wrong**: "Workflow created! Please test it."
- **Right**: Test it yourself, debug failures, only report after confirmed working

### 8. Reporting success without actually testing
- **Wrong**: "Workflow is ready to use!" (without executing it)
- **Right**: Execute workflow, verify status=success, then report to user

### 9. Adding multiple nodes before testing (CRITICAL!)
- **Wrong**: Add Node A → Add Node B → Add Node C → Test → Error (which node failed?)
- **Wrong**: Add 2 nodes at once, test, then add 2 more
- **Right**: Add ONE node → Test → Add ONE node → Test → Repeat (ALWAYS)
- **Remember**: NEVER add more than one node without testing in between

### 10. Not verifying each node executed
- **Wrong**: Check only final status, assume all nodes ran
- **Right**: Check `runData | keys` to verify each node in execution results

### 11. Creating new workflows instead of updating
- **Wrong**: Create new workflow each time you want to add a node or fix something
- **Right**: Create ONE workflow, use PUT to update it incrementally, keep same workflow ID

---

## Incremental Build-Test Workflow (MANDATORY!)

**STOP! THIS IS THE MOST IMPORTANT RULE!**

---

### ⚠️ THE GOLDEN RULE ⚠️

## ADD ONE NODE → TEST → ADD ONE NODE → TEST → REPEAT

---

**NEVER add 2 or more nodes at once. NEVER.**

```
❌ ABSOLUTELY WRONG:
   Add Webhook → Add Scraper → Add Transform → Add Sheets → Test → Error
   (Which node failed? Nobody knows. Start over.)

✅ THE ONLY CORRECT WAY:
   Add Webhook → Test ✓
   Add Scraper → Test ✓
   Add Transform → Test ✓
   Add Sheets → Test ✓
   Done!
```

After adding EACH SINGLE node, you MUST:
1. **Execute** the workflow via webhook
2. **Check** execution status = "success"
3. **Verify** the new node appears in runData
4. **ONLY THEN** add the next single node

**If you add two nodes without testing between them, you are doing it WRONG.**

---

### Test with 10 Real Data Items

**ALWAYS test with at least 10 real data items, not just 1.**

```
❌ WRONG: Limit search to 1 item for testing
❌ WRONG: Use mock/placeholder data
❌ WRONG: Test with empty payload

✅ RIGHT: Set limit=10 or maxResults=10 on search/scrape nodes
✅ RIGHT: Use real API endpoints returning real data
✅ RIGHT: Verify all 10 items flow through the entire workflow
```

When configuring nodes that fetch data:
- Apify/scraper nodes: Set `maxResults: 10`
- HTTP Request to APIs: Include `?limit=10` or similar
- Database queries: Add `LIMIT 10`
- Search nodes: Set result limit to 10

**Why 10 items?**
- Reveals issues with array handling
- Tests performance under realistic load
- Exposes edge cases in data transformation
- Ensures the workflow handles multiple items correctly

---

### Pin Data After Successful Execution

**CRITICAL: After a node successfully fetches external data, PIN the data immediately.**

Pinning saves the node's output so subsequent test runs use cached data instead of making new API calls.

```
✅ CORRECT WORKFLOW:
1. Add scraper node → Execute → SUCCESS (got 10 real items)
2. PIN the scraper node's output data
3. Add transform node → Execute (uses pinned data - instant!)
4. PIN the transform node's output
5. Add storage node → Execute (uses pinned data - instant!)
6. Continue building...
```

**Why pin data?**
- **Speed**: No waiting for slow API calls on every test
- **Cost**: Avoid repeated API charges (Apify, OpenAI, etc.)
- **Consistency**: Same test data every run
- **Reliability**: External APIs can fail/change - pinned data is stable

**How to pin via API:**

After successful execution, update the workflow with pinned data:

```bash
# 1. Get execution data
export $(cat .env | grep -v '^#' | xargs) && curl -s "${N8N_API_URL}/api/v1/executions/{EXECUTION_ID}?includeData=true" -H "X-N8N-API-KEY: ${N8N_API_KEY}" | jq '.data.resultData.runData["Node Name"]'

# 2. Update workflow with pinned data in the node
curl -s -X PUT "${N8N_API_URL}/api/v1/workflows/{WORKFLOW_ID}" \
  -H "X-N8N-API-KEY: ${N8N_API_KEY}" \
  -H "Content-Type: application/json" \
  -d '{
    "nodes": [
      {
        "id": "node-id",
        "name": "Scraper",
        "type": "...",
        "pinData": {
          "Scraper": [
            {"json": {"name": "Item 1", ...}},
            {"json": {"name": "Item 2", ...}}
          ]
        }
      }
    ],
    ...
  }'
```

**Workflow-level pinned data structure:**
```json
{
  "name": "My Workflow",
  "nodes": [...],
  "connections": {...},
  "pinData": {
    "Scraper Node": [
      {"json": {"field1": "value1"}},
      {"json": {"field2": "value2"}}
    ],
    "HTTP Request": [
      {"json": {"response": "data"}}
    ]
  }
}
```

**When to pin:**
- After scraper/crawler nodes fetch data
- After HTTP requests to external APIs
- After AI/LLM nodes generate responses
- After any slow or expensive operation

**When NOT to pin:**
- Trigger nodes (webhooks, schedules)
- Final output nodes (Respond to Webhook)
- When you need fresh data for testing

### One Workflow, Keep Updating
- Create workflow ONCE with POST → get workflow ID
- All subsequent changes use PUT to the SAME workflow ID
- Never create a new workflow just to test or fix something

---

### STEP-BY-STEP PROCESS (FOLLOW EXACTLY)

#### Step 1: Create Workflow with Trigger Only
```bash
export $(cat .env | grep -v '^#' | xargs) && curl -s -X POST "${N8N_API_URL}/api/v1/workflows" -H "X-N8N-API-KEY: ${N8N_API_KEY}" -H "Content-Type: application/json" -d '{
  "name": "My Workflow",
  "nodes": [{
    "id": "webhook-1",
    "name": "Webhook",
    "type": "n8n-nodes-base.webhook",
    "typeVersion": 2,
    "position": [250, 300],
    "parameters": {"path": "my-workflow", "httpMethod": "POST"}
  }],
  "connections": {},
  "settings": {"executionOrder": "v1"}
}' | jq '{id, name}'
```
**Save the workflow ID - you'll use it for ALL updates.**

#### Step 2: Activate the Workflow
```bash
export $(cat .env | grep -v '^#' | xargs) && curl -s -X POST "${N8N_API_URL}/api/v1/workflows/{WORKFLOW_ID}/activate" -H "X-N8N-API-KEY: ${N8N_API_KEY}" | jq '{id, active}'
```

#### Step 3: Test the Trigger
```bash
export $(cat .env | grep -v '^#' | xargs) && curl -s -X POST "${N8N_API_URL}/webhook/{WEBHOOK_PATH}" -H "Content-Type: application/json" -d '{"test": "data"}'
```

#### Step 4: Verify Execution
```bash
export $(cat .env | grep -v '^#' | xargs) && curl -s "${N8N_API_URL}/api/v1/executions?limit=1" -H "X-N8N-API-KEY: ${N8N_API_KEY}" | jq '.data[0] | {id, status}'
```

**STOP HERE if status ≠ "success". Debug and fix before continuing.**

#### Step 5: Add Next Node (PUT to update)
```bash
export $(cat .env | grep -v '^#' | xargs) && curl -s -X PUT "${N8N_API_URL}/api/v1/workflows/{WORKFLOW_ID}" -H "X-N8N-API-KEY: ${N8N_API_KEY}" -H "Content-Type: application/json" -d '{
  ... existing nodes + new node + updated connections ...
}'
```

#### Step 6: Test Again
```bash
export $(cat .env | grep -v '^#' | xargs) && curl -s -X POST "${N8N_API_URL}/webhook/{WEBHOOK_PATH}" -H "Content-Type: application/json" -d '{"test": "data"}'
```

#### Step 7: Verify New Node Executed
```bash
export $(cat .env | grep -v '^#' | xargs) && curl -s "${N8N_API_URL}/api/v1/executions?limit=1" -H "X-N8N-API-KEY: ${N8N_API_KEY}" | jq '.data[0] | {id, status}'
```

**Check which nodes ran:**
```bash
export $(cat .env | grep -v '^#' | xargs) && curl -s "${N8N_API_URL}/api/v1/executions/{EXECUTION_ID}?includeData=true" -H "X-N8N-API-KEY: ${N8N_API_KEY}" | jq '.data.resultData.runData | keys'
```

**STOP HERE if status ≠ "success" or new node not in runData. Debug and fix.**

#### Step 8: Repeat Steps 5-7 for Each Additional Node

**NEVER skip the test step. NEVER add multiple nodes without testing.**

---

### Example: Correct Build Process

```
✓ Step 1: Create workflow with Webhook
✓ Step 2: Activate
✓ Step 3: Test → Execute webhook
✓ Step 4: Verify → status: success, runData: ["Webhook"]

✓ Step 5: Add Apify Scraper node (PUT)
✓ Step 6: Test → Execute webhook
✓ Step 7: Verify → status: success, runData: ["Webhook", "Apify Scraper"]

✓ Step 5: Add AI Analysis node (PUT)
✓ Step 6: Test → Execute webhook
✓ Step 7: Verify → status: success, runData: ["Webhook", "Apify Scraper", "AI Analysis"]

... continue for each node ...

✓ Final: All nodes tested and working → Report to user
```

### WRONG vs RIGHT

**WRONG (DO NOT DO THIS):**
```
Add Webhook → Add Scraper → Add AI → Add Sheets → Test → Error → ???
```

**RIGHT (DO THIS):**
```
Add Webhook → Test ✓ → Add Scraper → Test ✓ → Add AI → Test ✓ → Add Sheets → Test ✓ → Done
```

### What to Report to User

**NEVER say:**
- "Workflow created! Please test it."
- "Here's the workflow, you'll need to configure..."
- "The workflow is ready" (without testing)

**ALWAYS say (after incremental build + test):**
```
✅ Workflow built and tested successfully!

Build Progress:
1. ✓ Webhook trigger - working
2. ✓ Apify scraper - working (returned 100 results)
3. ✓ Google Sheets - working (data saved)

Final Test: ✓ Complete workflow executed successfully

- Workflow: LA Dentists to Google Sheets
- ID: abc123
- URL: https://n8n.example.com/workflow/abc123
- Status: Active

Ready to use!
```

**If manual config needed:**
```
✅ Workflow built and partially tested!

Build Progress:
1. ✓ Webhook trigger - working
2. ✓ Apify scraper - working (returned 100 results)
3. ⚠ Google Sheets - requires manual setup

Manual Step Required:
The Google Sheets node needs you to select the spreadsheet in the n8n UI.
This uses OAuth document picker which cannot be done via API.

→ Open: https://n8n.example.com/workflow/abc123
→ Click "Google Sheets" node
→ Select your spreadsheet
→ Save

After that, the workflow will be fully functional.
```

---

## Best Practices

### Creating Workflows

1. **Generate unique node IDs**: Use UUIDs or descriptive IDs
2. **Use proper positioning**: Start at [250, 300], space nodes ~200px apart
3. **Set executionOrder to "v1"**: Modern execution order
4. **Add error handling**: Include error outputs where appropriate
5. **Always include webhook trigger** if the user wants to run via API
6. **Always test before reporting success**

### Node Naming

- Use descriptive names: "Fetch Customer Data" not "HTTP Request"
- Avoid duplicate names within a workflow
- Keep names concise but meaningful

### Connections

- Connection keys use node **names**, not IDs
- Main outputs: `"main": [[{...}]]`
- Multiple outputs: `"main": [[{...}], [{...}]]`
- Error outputs connect to error handling nodes

---

## Error Handling

### Common API Errors

| Status | Meaning | Solution |
|--------|---------|----------|
| 401 | Unauthorized | Check API key is valid |
| 404 | Not found | Check workflow/execution ID exists |
| 400 | Bad request | Validate JSON structure |
| 409 | Conflict | Workflow name may be duplicate |
| "method not allowed" | Wrong HTTP method | Use PUT for updates, POST for activate |

### WorkflowHasIssuesError

If execution fails with `WorkflowHasIssuesError`:
1. Check for nodes with incomplete configuration (empty required fields)
2. Common cause: Google Sheets without documentId selected
3. User must open workflow in n8n UI to complete configuration

### Debugging Execution Errors

**IMPORTANT**: When debugging, always fetch only the **most recent 1-2 executions**, not all. This keeps context focused and relevant.

**List recent executions (limit to 2):**
```bash
export $(cat .env | grep -v '^#' | xargs) && curl -s "${N8N_API_URL}/api/v1/executions?limit=2" -H "X-N8N-API-KEY: ${N8N_API_KEY}" | jq '.data[] | {id, status, startedAt, workflowId}'
```

**Get error details from most recent execution:**
```bash
export $(cat .env | grep -v '^#' | xargs) && curl -s "${N8N_API_URL}/api/v1/executions/{EXECUTION_ID}?includeData=true" -H "X-N8N-API-KEY: ${N8N_API_KEY}" | jq '.data.resultData.error'
```

---

## Integration with Other Skills

### Using the Credentials Template

**IMPORTANT**: When creating workflows, use the `benai-skills:n8n-credentials` skill to fetch the credentials template. Copy the **FULL node configuration** from template nodes, not just credentials.

**What to copy from template nodes:**
1. `credentials` - The credential references (id, name)
2. `parameters` - All node parameters (resource, operation, settings, etc.)
3. `typeVersion` - The exact version used in the template

**Example - Creating a Slack node from template:**

First, fetch template and find the Slack node:
```bash
export $(cat .env | grep -v '^#' | xargs) && curl -s "${N8N_API_URL}/api/v1/workflows/{TEMPLATE_ID}" -H "X-N8N-API-KEY: ${N8N_API_KEY}" | jq '.nodes[] | select(.type | contains("slack"))'
```

Then use the **entire node configuration** as your base:
```json
{
  "id": "new-unique-id",
  "name": "Send Slack Message",
  "type": "n8n-nodes-base.slack",
  "typeVersion": 2.2,
  "position": [450, 300],
  "parameters": {
    // COPY ALL PARAMETERS FROM TEMPLATE NODE
    "resource": "message",
    "operation": "post",
    "channel": "#general",
    // ... all other parameters from template
  },
  "credentials": {
    // COPY CREDENTIALS FROM TEMPLATE NODE
    "slackApi": {
      "id": "from-template",
      "name": "from-template"
    }
  }
}
```

**Why copy full configuration?**
- Template nodes have tested, working configurations
- Ensures correct `typeVersion` compatibility
- Includes all required parameters with valid values
- Prevents "missing required field" errors

---

## Quick Reference

| Operation | Method | Endpoint |
|-----------|--------|----------|
| List workflows | GET | `/api/v1/workflows` |
| Get workflow | GET | `/api/v1/workflows/{id}` |
| Create workflow | POST | `/api/v1/workflows` |
| Update workflow | **PUT** | `/api/v1/workflows/{id}` |
| Delete workflow | DELETE | `/api/v1/workflows/{id}` |
| Activate workflow | **POST** | `/api/v1/workflows/{id}/activate` |
| Deactivate workflow | **POST** | `/api/v1/workflows/{id}/deactivate` |
| List executions | GET | `/api/v1/executions` |
| Get execution | GET | `/api/v1/executions/{id}?includeData=true` |
| Execute via webhook | POST | `/webhook/{path}` (workflow must be active) |

Always read `.env` first to get `N8N_API_URL` and `N8N_API_KEY`.
